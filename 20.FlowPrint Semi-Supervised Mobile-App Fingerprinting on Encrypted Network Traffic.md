@[TOC](Fingerprinting on Encrypted Network Traffic)

# Abstract & Introduction

手机应用指纹可以提供网络中app的活动状态，因此十分重要。但是移动网络环境的实时变化（安装，更新，卸载）使得目前的移动指纹识别模型无法覆盖网络的所有app类型。

同时，移动流量加密广泛出现，因为加密库的广泛使用，以及内容分发网络的使用。加上移动网络极易受到用户输入的影响，因此任务复杂。

> CDN：利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。

本文的FlowPrint可以：

- 自动提取网络流量中，时间上相关的flow在通信dst地址上的相关性特征，并利用这种相关性特征来产生app指纹。
- 这种方法可以对之前没见过的app建立设备指纹，这是目前技术做不到的。

## Introduction

移动安全包括防止对IT基础设施的破坏。在大型企业中，一般采取安装监事代理的方法来保护每个设备。

但是因为代理对设备上安装的app没有直接控制权，尤其是员工携带私人设备进入公司，而且可以在私人设备上随意安装软件，这种设备接入网络时会产生难以监管的威胁。为了管理，目前采取的办法是检测产生的手机流量，这种方法在加密流量中收效甚微，而80%的流量都是加密的（TLS）。

另一方面，识别出手机上的app种类，一方面可以在不干扰用户正常流量的前提下，提供流量分析；另一方面也可能被用于审查和入侵用户隐私。因此，用户有必要知道在加密流量环境下，使用app会泄露多少信息，从而考虑额外策略，包括VPN等等。

目前的方法都是基于先验知识的，对于动态变化的移动网络环境效果很差，光是谷歌商店包含2500000种app，加上byol策略，就无法都获取先验知识。因此，未知设备只能被误分类，或者归为一个unknown大类，减少模型识别能力。

在我们的模型中，产生的app指纹作为marker使用，既可以用于识别已知设备，也可以用于自动识别和隔离未知设备。安全员就可以根据设备归类，来更新网络白名单，黑名单，或者实施有目标的调查（针对一组app的网络流量）。

主要挑战有三：

- 流量相似性。手机流量具有相似性，因为很多app都是基于library二次开发，在认证，广告，调试分析等过程中会表现出相似的行为。而且大部分app应用层协议都是http/https。更进一步，一部分流量内容使用了CND或者云服务商提供的主机来传输流量，流量特征在使用这些代理的过程中被消除了。因此，我们的方法是利用app通信的目的地址不同。尽管有很大一部分app地址是相互交错的，用独有的部分也足够构建网络流量特征。
- 多样性。手机流量的动态变化性，来源于app用户的行为不同（例如导航软件流量会因路线不同而变化）。我们的方法同样是根据通信的目的地址来建立对用户交互行为具有高鲁棒性的指纹，因为用户对网络通信的目的地址难以干预，一般由运营商策略和地理位置决定。
- 动态变化性。app的安装，更新，删除行为都会使得已有模型性能下降和覆盖范围降低，尤其是需要先验知识的模型。我们通过使训练的模型偏向于在训练中发现模式，而不是仅仅拟合训练数据追求准确率。
- 具体而言，app都是由模块组成，每个模块的通信目的地址是相对固定的（和 you are what you broadcast的每种广播协议行为相对固定很像）。因此，我们以模块为单位，寻找网络流量通信的dst地址集合，构建pattern。在更高的层面上，通过对加密的TCP/UDP数据流基于dst地址进行聚类，寻找频繁同时访问的目的地址，得到dst地址集合。

关于本模型，虽然不需要先验知识，可以说是无监督学习，但是在实际应用时是半监督的。具体来说，对于移动设备，我们都赋予一个匿名标签。这个标签用于区分唯一的app，不是用来查找对应的设备名称进行赋值。例如我们知道谷歌地图app，就对谷歌地图的flows标记为unknown_app_x。相似的，在识别到未知设备时，需要基于一些已知app来识别未知app。

贡献：

- 一个使用目的地址聚类+浏览器隔离+模式识别的模型。
- 第一个实时的，构建移动app指纹的，能识别未知设备的系统。
- 效果好。

# Preliminary analyse

在一个小数据集上进行先验测试，目的是找到具有强代表性和区分度的表示器，来识别手机应用。

## 数据集

![image-20231127102309848](C:\Users\8208191402\Desktop\笔记\图片\image-20231127102309848.png)

使用加密流量数据，以app为分类标准。这些数据集包含

- 人造数据和用户产生的数据
- Android/iOS
- 正常的/可能的恶意app
- 不同应用商店，不同version的app。

只是用一下数据集的一小部分，防止偏差。

- ReCon
- Cross Platform
- Andrubis
- Browser

最后一个数据集是实验专门收集的。

## 特征提取

考虑所有可能构成指纹的网络流量特征。加密流量环境下，可用的只有时间相关性，基于包大小的特征，以及未加密层的元数据（数据包header），以及TLS认证阶段的握手信息。

具体而言，提取通信app链路层和应用层之间的，所有层的包头字段，包大小，包之间的时间间隔。此外，根据包大小和时间相关的特征，计算一些统计特征：最大最小，均值方差，10和90分位数之间的值。

## 特征排序

对所有特征进行打分，使用调和互信息(AMI)来表示特征聚类结果之间的相关程度。对于其他方法，例如信息增益会受到随机取值字段的影响。

*随机取值字段在监督/**半监督学习**中都是不良的，因为模型对于字段的取值没有先验知识，随机取值会影响模型的初始迭代。*

AMI定义了知道一个特征的值对于分类结果（在本文中是app类型）产生的，增加的熵的比例。

因此，使用下面的公式计算特征和对应app之间的相互关系。
$$
MI(X,Y)=\sum_{y \in Y} \sum_{x \in X}p(x,y)log(\frac{p(x,y)}{p(x)p(y)}) \\
Y对应每一批样本中类的集合，X对应样本的特征的总集合\\
p(x,y)表示联合概率分布，p(x)p(y)是边缘分布
$$


AMI在上述基础上，用正则化来平衡有多个取值的特征的信息熵。AMI=0表示完全无关，=1表示X可以一一对应到标记Y上。AMI定义如下
$$
AMI(X,Y)=\frac{MI(X,Y)-E[MI(X,Y)]}{max(H(X),H(Y))-E[MI(X,Y)}\\
E[MI(X,Y)表示均值，H(X),H(Y)表示熵
$$

## 特征评估

根据得分与排序，进行最终评估。

AMI是一个计算离散值得分的指标，因此对于连续值进行区间划分和值映射。选取特征如下：

![image-20231127102442937](C:\Users\8208191402\Desktop\笔记\图片\image-20231127102442937.png)

1. 没有特征的AMI接近于1，因此需要组合特征来构建指纹，进而构建可靠的app marker。

   > 在流量识别（Traffic Classification）领域，"App Marker"（应用标记）通常是指一种标识网络流量中特定应用程序的方法或标志。网络流量中的数据包可以通过各种方式来标识其所属的应用程序。

2. 根据分类结果对特征的受益程度（信息增益的正则化形式-> AMI），选择四种特征：

   - 时序特征。包括流之间的和包之间的时间间隔。大多数app只在active状态下通信，研究表明只有一小部分app能同时处于active状态。时序特征的劣势在于容易受到一个小时间窗口内网络延迟和拥塞的影响。结合上面两点，我们的工作选择一个更加粗粒度的时间特征：flow之间的时间间隔。通过flow之间的时间间隔，来对同一个时间interval之间的流量进行关联。注意，这不是新的发现，但实验证明是高效的。

     ![whiteboard_exported_image](C:\Users\8208191402\Desktop\笔记\图片\whiteboard_exported_image.png)

   - 设备特征。

     - 源IP地址：源ip是待检测设备的，表明产生网络流量的设备泄露了app的信息。因为设备的app不止一个，而且受用户行为影响有多样性，因此选择ip为特征单位没有固定的意义，转而选择**设备本身**为创建app指纹的特征之一。

       选择以设备为基础，进行app识别，有助于限制设备行为动态性。不同设备厂商和OS版本的设备会产生截然不同的设备流量，因此具有一定的区分度。

       > 总的来说，用户设备作为流量识别的最小单位而非ip地址，一方面可以减少多个app在同一个设备上运行产生的流量动态变化，另一方面可以充分利用**设备的厂商信息和OS版本信息**，提供额外的特征区分度。

     - 目的ip地址：目的ip是服务器的ip地址，或者TLS认证的安全服务器地址。app可以通过通信的目的地址来区分。根据不同模块的功能不同，通信的服务器地址也不同。这些目的地址构成的集合可以标识一类具有特定功能，或者来自特定厂商的设备。*因为DNS流量中的域名信息受到DNS缓存信息的影响，不使用域名作为特征。*网络通信的目的ip是会动态变化的，但这是一个动态模型，目的ip变化开销很小，可以实现动态更新，只要模型具有类似DNS服务器的功能模块即可。

   - 大小特征。每个流中包含的发送和接收数据量大小，可以用于表明哪个app处于活跃状态。但是根据图表所示，size相关的AMI太低，在监督学习中效果可能还好，在本模型中不考虑。

# 威胁模型

前提

- 在NAT和动态ip环境下，能够追踪到设备相关的flow
- 区分手机和非手机设备
- 只检查自己网络内的流量（公司内的WiFi）

适用于公司应用场景，安全员可以看到网络的所有流量，能够接入DHCP服务器。

> 动态主机配置协议（Dynamic Host Configuration Protocol，DHCP）是一种网络协议，用于在计算机加入网络时为其分配IP地址和其他网络配置信息。DHCP允许网络管理员集中管理和自动分配IP地址，以简化网络配置并减少潜在的地址冲突。
>
> 以下是DHCP协议的主要特点和工作原理：
>
> 1. **自动IP地址分配：** DHCP允许网络中的设备在连接到网络时自动获取IP地址，而无需手动配置。这使得在大型网络中添加新设备更加方便。
> 2. **动态分配：** DHCP支持动态分配IP地址，这意味着设备在每次连接到网络时可能会获得不同的IP地址。这有助于最大程度地利用IP地址池，并减少地址浪费。
> 3. **配置参数分配：** 除了IP地址外，DHCP还可以分配其他网络配置参数，如子网掩码、默认网关、DNS服务器等。这些参数有助于设备正确配置其网络连接。
> 4. **租约：** 分配给设备的IP地址是有时限的，称为租约期限。设备在租约到期前需要更新租约，以继续使用分配的IP地址。这有助于确保IP地址池中的地址得到及时释放，以供其他设备使用。
> 5. **DHCP消息：** DHCP通信涉及客户端和服务器之间的消息交换。主要的DHCP消息包括Discover（客户端发现）、Offer（服务器提供）、Request（客户端请求）、和Acknowledge（服务器确认）等。
> 6. **广播通信：** 初始的DHCP请求通常以广播形式发送到网络上的所有设备，但服务器的响应只会发送给发出请求的客户端。这有助于减少网络中的不必要通信。
>
> DHCP在现代网络中广泛使用，特别是在局域网（LAN）和家庭网络环境中。通过自动分配和管理网络配置，DHCP简化了网络管理过程，提高了网络的灵活性和可维护性。

研究表明，管理员可以根据MAC地址和其他正交的OS指纹特征，来区分移动端流量和网络他流量，包括DHCP消息、TCP/IP包头，OS特定的目的地址（OS版本更新的服务器ip和手机应用市场的ip）。

这时候就可以从手机流量中构建每个app的指纹了。基于如下假设：

- 每个手机app一次只执行一个，即多个app之间的流量不交叉，这就是基于**app只在active状态下才会通信**引申出来的结论，只有一个前台相当于只有一个程序在执行。而且多个app执行之间有间隔。

  *后台服务的流量数量更少，模式更加易识别。*

  *多个app同时执行，就会产生混合指纹，本文还没做到那一步，更多是聚焦于对未知设备的识别。*

# 方法

基于：手机app由多个组件构成，每个组件和一个相对不变的网络目的地址通信。本文聚焦于发现这些具有区分度的通信模式，而不需要知道当前active的app的先验信息。因此，本模型适用于不断更新的app套件（OS更新，应用市场更新），同时不受移动端流量同一性和动态性本质的影响。

overview

![9C3615C4FED13B69446934F51785F29C](D:\QQ文件\MobileFile\9C3615C4FED13B69446934F51785F29C.png)

1. 周期性采集当前网络的设备流量，为设备当前活跃的app生成指纹。

2. 以TCP/UDP flow为单位，切分每个设备的网络trace，提取需要的特征。

3. 根据flow的dst地址聚类。

   同时，把行为类似于浏览器的app隔离。因为浏览器是一个获取网络信息的平台应用，不是具有某种专门功能的app，因此不具备可辨识的特征。

4. correlation：对聚类的cluster根据时间相关性，把相关的网络活动聚到一起，得到一个备选app指纹。

5. 当聚类表现出强时间相关性（temporal access pattern），可以得到一个最终的app指纹。

6. 把指纹和指纹库进行对比，实现设备识别和新设备发现。

## A.特征提取（特征数据获取）

1. 分别查看手机设备使用的TCP/UDP flows，提取ip地址，端口，时间戳，大小，包的方向。可行的话还要获取这个flow使用的TLS证书。

2. 在聚类阶段，根据目标IP和端口号，使用的TLS证书作为聚类条件。

   在隔离浏览器的时候，还需要获取发送到网络上的数据总量，来判断是不是浏览器。

3. 最后correlation的时候，还需要数据包的时间戳，来判断不同flow的时间相关性。

## B.聚类

之前提到的，对一个interval之内的flow进行聚类就是这里。因为代码是实时性运行的，因此周期性的获取输入数据，然后根据时间间隔（interval）把数据分为一系列batch，在每个batch内提取特征。提取之后，基于目的地址对flows聚类。同一类标准：

- flows的dst ip和port相同

- flows的TLS证书相同。

  > CDN软件分发网络中，目的地址不是真实的，而是CDN服务的入口地址，具体地址由CDN服务商选择。
  >
  > web服务为了缓解高峰期的流量负载平衡和减少响应时间，会为一个目的地址设置多个ip，这就需要TLS证书来识别相同的flow。

聚类结果实例，目标聚类是随机分布的。

![image-20231127145824009](C:\Users\8208191402\Desktop\笔记\图片\image-20231127145824009.png)

- 某些聚类是多个app产生的（共用某一个app module），成为shared cluster。

这些聚类往往属于第三方服务，包括崩溃分析、移动广告网络、社交网络、CDN。这些app大多使用同一个库实现。

衡量这些聚类对指纹生产有多大的影响：section V-E

- 某些聚类只在特定app上出现，往往标识了app的开发者，或者第三方服务的供应商总服务器。

只有当有flow发往/来自这个cluster，我们才认为这个cluster是active的，否则是inactive的。

## C.浏览器隔离

浏览器不属于专注于某一类职能的app，因此隔离所有的browser为一类。

从目的地址聚类的角度，浏览器会产生非常多的，新的cluster。现代网站大多把存储的内容分布式存储在CDN节点，通过广播广告信息和辅助的脚本来加载图像等资源。分布式存储的性质就决定了会有非常多的目的地址聚类。

从网络行为分析，浏览器下载、存储用于展示的数据远大于上传的数据（cookie等）。其他应用的行为会更加一致和持续。

这两点就是区分浏览器和其他app的标准。但多个app同时处于active时也会展示出对应的行为，因此使用相对变化比率来判别：

- 相对的活跃cluster数量

- 上传字节数的相对改变量

- 下载字节数的相对改变量

- 上传/下载的比率相对改变量

- $$
  相对改变量=\frac{(基准值新值−基准值)}{基准值}×100\%\\
  改变量 = (基准值新值−基准值)
  $$

为了识别和隔离浏览器app，训练一个随机森林模型，用标记的浏览器/非浏览器数据训练。

当分类器检测到浏览器时，隔离[t-10,t+10]范围内的所有active connection，把这些连接和对应的flow都从目的地址聚类中移除。

## D.聚类的关联

基于假设：不同时间点上，活跃目的地址聚类的二次聚类是唯一性的，而且每个app的二次聚类模式是相对固定的，都表示自身app的功能。

根据时间上的相关性，对聚类进行关联，得出网络行为pattern。分析的是活跃目的地址聚类的时间相关性。

关联图构建

- 为了计算不同聚类的时间相关性，对所有聚类c进行笛卡尔乘积得到聚类对<ci,cj>，计算所有聚类pairs交叉熵。

- 把输入数据根据时间窗口window切片，对每个切片内的聚类计算交叉熵。
  $$
  (c_i,c_j)=\sum_{t=0}^Tc_i[t] · c_j[t]
  \\c_i=1 \quad if \quad active
  $$
  正则化，减少具有更多活动类型的聚类的得分。

$$
(c_i,c_j)_{norm}=\frac{\sum_{t=0}^Tc_i[t] · c_j[t]}{\sum_{t=0}^Tmax(c_i[t] · c_j[t])}
$$

现在可以构建交叉熵矩阵，每一行/列代表一个cluster。节点之间用边连接，权重为交叉熵的值。

下图展示了三个app的cluster关系图。

![image-20231127163344918](C:\Users\8208191402\Desktop\笔记\图片\image-20231127163344918.png)

- 同一个app的cluster往往有强相关性。
- 多个app共享的cluster在每一个app中都只具有弱相关性。
- 每一个app唯一性的（某个app特有的）cluster几乎不相关。

## E . app指纹

最后一步，构建指纹，需要选择最大的集群/最显著的二次聚类，可以是完全子图，或者cluster的强联通分量。

1. 移除cluster节点之间的弱相关性边，只保留强相关性边，阈值T=0.1。
2. 提取图中的最大联通分量。
3. 最大联通分量都是完全子图，因此我们忽视关联度的大小（连通分量的边没有意义），使用网络通信目的地址集合来代替子图以节省存储空间，每个节点保留（dst ip，dst port）和TLS证书。

定义设备指纹：集合，在关联图中，能代表一个最大联通子图的集合就是一个app的指纹。

图中的cluster如果不与其他节点有交互的flow，就不会有边，即完全脱离图的结构。这些节点一般是多个app共享的，与多个app的相应公共模块的cluster有弱交互。

![image-20231127163344918](C:\Users\8208191402\Desktop\笔记\图片\image-20231127163344918.png)

还是这张图，这些孤儿节点本身对设备识别没有价值。但是，和设备的其他显著特征结合，可以增加批处理时（多个设备流量存在）特征的信息量。因此，我们把这些孤儿节点合并到时序上最接近的flow所在的聚类中。

## F.特征比较

特征可以不需要先验知识从图中提取，但是，用户行为变化和时间变化，以及app功能的变化，都会导致通信的目的地址集合变化。因此，使用模糊匹配和Jaccard相似度来衡量特征之间的相似性。

基于特征使用set进行标识，我们使用Jaccard矩阵，当两个指纹的Jaccard相似度大于阈值，则认为这是同一个指纹。
$$
J(F_a,F_B)=\frac{F_a \and F_B}{F_a \or F_B}
$$
这样，我们就可以比较同一个app在时序上的变化特性，也可以追踪多个不同输入batch，甚至不同程序执行周期之间的app activity相似度。

模糊匹配还可以扩大指纹集合的大小。当连通分量扩大时，有的边可能会小于阈值，从而使连通分量丢弃这个节点。

此外，对于指纹相似的app，可能是同一个app的多次执行产生细微差别导致的，这样就允许我们吧相似指纹视为同一个。

# Evaluation

使用python的NetworkX来执行图计算。

第一个实验用来确认方法的最优参数，然后测试我们的指纹识别设备的准确率，接着测试我们的模型在对未知app的识别能力，包括更新和安装的app。

本模型训练不需要标签，但是需要绝对正确的标签内容来验证模型的正确性。这一点可以通过在手机应用上可以通过部署intrusive monitoring agent主动监测来实现。

> 在移动流量分析中，"Intrusive Monitoring Agent"（侵入性监测代理）是指在网络中主动部署的一种监测工具或代理，用于收集和分析网络流量。这种代理通常被插入到网络中，以监视特定的流量、收集数据、执行分析，并可能采取一些响应性的措施。
>
> 关键特征和功能包括：
>
> 1. **主动部署：** Intrusive Monitoring Agent 是通过主动部署到网络中的一种工具。它可以被部署在网络的关键节点。
> 2. **流量收集：** 代理能够捕获和记录经过它所在位置的网络流量。包括从移动设备到网络基础设施和设备之间的通信。
> 3. **数据分析：** 收集到的流量数据会被代理用于流量模式的检测、异常行为的识别、网络性能的评估等。
> 4. **安全监测：** 在移动流量分析的上下文中，用于检测网络中的安全威胁，如恶意软件、攻击行为等。
> 5. **性能优化：** 通过监测网络流量，用于评估和优化网络性能，以确保高效的数据传输和通信。
>
> 需要注意的是，"Intrusive" 这个词可能被解释为对网络本身有一定程度的影响或干扰。这可能是因为它需要主动地介入网络通信过程，以便收集更详细的信息。这与一些被动式监测方法（如流量镜像）有所不同。在使用侵入性监测代理时，需要谨慎考虑对网络性能和可用性的潜在影响。

考虑到隐私问题，通过重放数据集流量（具体有哪些前面讲过），训练：测试 = 1:1。

对于设备检测，随机选择100个app，对于ReCon和Anrubis，每个app平均生成2个指纹，对于Cross PlatForm平均6.2个。

对于未知设备，随机引入20个数据集不包含的app流量。

## 参数

$$
T_{batch}，\text{表示每个batch需要process的时间}，optimal=300s\\
T_{window}，表示在这个时间内，同时active的app被认为是同步active的，optimal=30s\\
T_{correlation}，决定是否保留连通分量边的阈值，optimal=0.1\\
T_{similarity}，Jaccard相似度阈值，用于确认两个指纹是否可视为同一个，optimal=0.9
$$

根据模型的f1得分优化。参数优化矩阵计算准确率和回归率的调和平均数（2/倒数和相加）。

把得到的指纹映射到app label来验证准确率，验证用的flow都是labeled的，指纹的label就选择最多的flow的label。这种方法产生的多个指纹可以通过映射到一个指纹，防火墙也允许一个app有多个指纹。

对于batch的时间，也就是说一个flow需要30秒才能生成一个指纹。为了效率，可以减少batch时间，代价是牺牲准确率。

## app识别

1. 使用带标签的flow，生成训练数据的指纹。
2. 根据指纹内最多的，flows的app标签，为每个指纹确定标签，获取训练数据集的指纹标签。
3. 在测试集上使用本文模型获取测试集指纹。
4. 把测试集指纹和训练集对应类别的指纹对比，使用Jaccard相似性来表示比较结果。
5. 因此，每个测试指纹和包含的flow，都和训练集产生的指纹中最相似的那个，具有相同的标签。

![image-20231127221617787](C:\Users\8208191402\Desktop\笔记\图片\image-20231127221617787.png)

