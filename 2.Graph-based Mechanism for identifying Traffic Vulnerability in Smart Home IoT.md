# Abstract

> 主要研究的是通信过程中的漏洞，也就是流量中的。
>
> 根据捕获的流量所在的设备不同，选择多个packet capture file作为输入。
>
> - 通过检测不同消息之间的attribute-value对的对应关系，辨别相关的通信子图。
>
> 不需要设备的软件信息，识别新的vulnerability
>
> 关注点：
>
> - 在IoT通信过程中探测漏洞
> - 测试环境：Google Home smart speaker，smart light bulb ，smartphone
> - 只需要很少的，或者不需要用户凭证（用户名和密码、数字证书、智能卡）
> - 实际网络中，会有很多复杂的、无关的信息，而短时间间隔内的消息往往用于实现一个特定的网络功能（绑定账户，认证设备）

# BackGround

> 步骤：
>
> - 采集IoT流量，构建流量图
> - 根据不同的行为，划分相关子图
> - 对每个子图，基于相关的流量中的“attribute-value”对，计算敏感程度
> - 六种攻击测试，包括获取用户隐私、夺取用户对IoT设备的控制权
>
> 外部通信
>
> - 智能设备需要和外部手机和服务器通信，大部分通信都是通过SSL/TLS加密，即对称加密
> - 敏感通过对称加密，存储在payload或request url中
> - 手机通过向智能设备发送控制命令
> - 手机通过向TP Server发送验证信息（手机用户的用户名和密码），来远端获取通过SSL/TLS加密的设备信息；或者通过接入本地网络，直接和设备通信，不需要验证。
> - 手机先向Google Home绑定设备，然后通过声音而不是App控制设备
>   - Google Home发送加密的用户控制语音到Google server进行分析
>   - Google server传递控制信号到TP-LINK server
>   - TP-LINK发送控制信号到设备
>
> 

# Approach

## Construct a directed graph based on traffic data

> traffic data来自PCF（Packet Capture file）文件
>
> 手机，设备，服务器都是节点
> $$
> e_{i,j}^t \in E \enspace is \enspace labeld\enspace by \enspace(c_{i,j}^t,t)\\
> $$
> C表示边e的属性，={"attribute1":"value1";"attribute2":"value2"}，就是一个字典
>
> 难点在于如何从流量中抽取边的属性
>
> - 流量在边上通过明文传输，则不需要解析属性，传输多使用get和post方法
>
>   - GET方法：
>
>     ```markdown
>     https://target_url?Attribute1=value1&Attribute2=value2....
>     ```
>
>   - POST方法：数据一般通过JSON格式传输/Protobuf格式传输
>
> - 加密流量
>
>   - 简单加密：对于不同流量，加密采用同一组秘钥进行加密，则通过逆向工程恢复秘钥。如果同一组信息加密得到的密文在不同时间是一致的，则说明是简单加密。（TP-LINK）
>   - SSL/TLS加密：尝试在相关设备中安装我们自己的证书；或者使用DNS注入攻击，来强迫设备和我们的流氓服务器通信，这样就可以和目标设备进行秘钥交换。
>   - 其他加密方式：使用侧信道信息（包长，时间戳）来预测加密消息的行为。通过手动标注+机器学习。（case3,4）

## Traffic-Based Correlated Subgraph Isolation

> 子图中的实体和边是功能上相关的，用于完成一系列action（注册/绑定设备，开关灯）
>
> ![](C:\Users\8208191402\Desktop\笔记\图片\图和子图.png)
>
> - v1->v2是手机向设备发送bind_user信号，v2->v3是设备箱服务器发送register_user信号
>
>   能构成这个子图，是因为两个消息都有相同的attribute：username和password
>
> - v1->v3->v2是手机通过服务器控制设备，v1->v3发送控制信号和用户的验证信息，server verigy token后，转发控制信息给设备
>
>   能构成这个子图，是因为两个消息都有相同的attribute：on_off

> Traffic-Based Subgraph定义：在子图SG（SE，EV）中，最新时间t
>
> - 存在一条边
>   $$
>   e_{k,m}^{t'}\in SE,\enspace t' > t\\
>   c_{i,j}^{t}\enspace\cap\enspace c_{k,m}^{t'}\enspace \neq \varnothing
>   $$
>   就把这条边加入到子图中
>
> - 因为我们无法获取Google server和TP-LINK server之间的消息，他们来自外部通信，但是我们知道他们通信存在转发的关系，因此也把这个边加入到子图中。
>
> - ![](C:\Users\8208191402\Desktop\笔记\图片\子图算法.png)
>
>   变种的kruskal算法

## 确定vulnerability traffic

> 每条边一个敏感等级，之和为子图的敏感等级，越高越安全
>
> ![](C:\Users\8208191402\Desktop\笔记\图片\敏感等级表.png)
>
> ![](C:\Users\8208191402\Desktop\笔记\图片\敏感值计算.png)
>
> 根据上述算法，分割出了流中漏洞相关子图，制定了六种攻击模式，其中三种攻击者需要获取用户的弱证书（“admin”，“123456”），另三种不需要任何的证书方面的先验知识。

## 测试环境

![](C:\Users\8208191402\Desktop\笔记\图片\测试环境图.png)

- 蓝：Google Home通信
- 绿：TP-LINK智能灯泡LB100通信
- 黑：智能手机和server通信
- 红：我们发现的劫持/攻击手段

> PCF文件格式：多个PCAP文件，来自攻击者手机、路由器router，恶意服务器，使用pypcapfile库
>
> - Google server和TP-LINK server都不会检测测试环境外部手机的certificate证书，因此，我们可以在智能手机中安装我们自己的证书，在手机上设置代理，确保所有经过智能手机的加密流量都能被我们破译。
> - Google server和TP-LINK server之间的通信，LB和TP-LINK server的通信也会加密，因此我们使用恶意服务器执行ARP-spooling攻击（更改IP到MAC地址的映射关系，让受害者IP连接到我们攻击者的MAC地址）和DNS注入攻击（向DNS服务器发送虚假的DNS响应数据，导致用户访问的网站被重定向到攻击者指定的恶意网站）
> - Google server和TP-LINK server在和smart device通信时，会做证书检测，分别查看是否是GeoTrust和Symantec签署的有效证书，而我们的攻击不需要对通信内容的完全解密就可以实现

> 测试步骤（15min）
>
> - 向两种智能设备绑定我们的账号
> - 对智能灯泡，通过APP/Google Home Voice控制，进行三十次on/off或者亮度调节指令
> - 通过APP（google home app/Kasa），检测智能设备的信息以及安全设置等配置
> - 执行多重交互攻击（multiple interaction），例如访问语音输入历史，访问气候信息来获取用户地理位置等等
>
> 忽略不重要的包，包括ACK，SYN，FIN，因为我们能获取包内的信息。
>
> 忽略不关心的包，如果通信流量双方都不是我们测试环境内的设备。
>
> 通过算法1选出相关子图，通过算法2获取高敏感度子图，选择前三十个进行测试，得出6种共计方案

### Case1：smartphone -- Google Home

![](C:\Users\8208191402\Desktop\笔记\图片\攻击模式1.png)

> google home app提供了几种控制操作允许手机用户对google home进行操作。
>
> 能识别出13个相关子图与这种方式有关，不加密，统一在端口8088执行。
>
> ![](C:\Users\8208191402\Desktop\笔记\图片\手机与谷歌家庭.png)
>
> 人工学习关系子图的相关性：
>
> - 包含`/setup/scan_result`的通信会暴露敏感信息，例如环境接入点列表
>
> - 获取用户家庭住址信息
>
>   - 攻击者可以请求（发送request）`/setup/scan_wifi`，来强迫google home扫描周围的WiFI
>
>   - 再通过发送`/setup/scan_result`请求来获取扫描结果
>   - 根据结果，调用Google Geolocation APIs来获取用户的精准住址
>   - 
>   - 但是安卓对于用户隐私访问有权限限制，我们可能在执行request方法时出现权限不足，因此使用一个恶意网站来代替我们完成任务。
>   - 攻击采用Websocket协议
>     - 当用户访问我们的恶意网站，网站使用PingModel去ping受害者LAN内的所有可用IP
>     - 使用Websocket API去向所有可达IP地址发送`/setup/scan_result`请求（使用Ajax post（）），同时注册一个listener，调用Ajax get（）去监听所有返回的周围环境接入点的list
>
> 

### Case2：smartphone -- Google Home -- Google Home Server

![](C:\Users\8208191402\Desktop\笔记\图片\攻击模式2.png)

> 攻击手机和Google home 以及他的server建立连接的过程，仍然使用恶意网站进行攻击
>
> 步骤：
>
> - 手机发送请求到`/setup/get_app_device_id`socket，获取google home的
>   - 内置certificate
>   - app_device_id
> - 手机完成OAuth2事务
>   - 向server发送authorization code，请求token
>   - server返回token
> - 手机发送link/unlink的request，包含
>   -  app_device_id
>   - certificate
>   - token
> - 连接已建立，可以request server，获取通过authorization code获取用户的语音输入历史



> - 攻击者可以保存一个有效的authorization code，unlink用户账号，自己绑定google home，获取并持续监听用户语音历史
>
> - authorization code存储在用户手机的指定位置下，本地保存，创建google account之后就不会变化
> - 攻击者可以通过
>   - ROOT权限获取
>   - 内存恢复工具，因为使用时会读入内存（rowhammer等等）

### Case3： Google Home -- Google Home Server -- TP-LINK server -- LB100

![](C:\Users\8208191402\Desktop\笔记\图片\攻击模式3.png)

> 攻击Google home的连接活动
>
> 子图通信解释：
>
> - 手机发送request到google home server，来建立所注册的google home和想要操作的LB100之间的连接
> - 建立连接后，用户向google home发送control指令，来开/关LB100
> - google home把用户的指令加密后，发送到google home server
> - google home server和TP-LINK server通信，最终发送control指令给LB100
>
> - 从google home上传到server的信息，和TP-LINK下达到LB100的信息，都是经过TLS加密的，加密证书都是机构认证的，我们无法获得，因此我们使用之前提到的第三种方法：侧信道
>   - 从google home上传到server的信息，和TP-LINK下达到LB100的信息几乎是同时发生的
>   - 经过反复测试，TP-LINK下达到LB100的数据包长度固定为182
>   - google home上传到server的信息需要通过机器学习
>     - 重复发出开/关指令400次，调高/低亮度指令400次，共计1600次
>     - 每种指令用350次来学习，50次用来测试
>     - 然后输入到 daubechies小波变换和决策树分类算法结合的机器学习模型中，用于判定输入的信息属于哪一个指令
>     - 准确率为85%，高于随机的25%，而且不需要解析加密的消息内容
>   - 基于学习出来的分类器，给子图中的消息添加一条属性`"function"：“GH LB100 on"`
> - 结合case2，我们可以利用窃取的authorization code建立虚假链接，然后利用解析出来的分类器截取消息，根据自己需求直接发送，而不需要解析消息的内容

### Case4：smartphone -- TP-LINK server -- LB100

![](C:\Users\8208191402\Desktop\笔记\图片\攻击模式4.png)

> 攻击从TP-LINK server发送到LB100的控制信息
>
> 通信流程：
>
> - 用户会首先将指令和自己的authorization code一起发送到路由器router，然后转发给TP-LINK server
> - TP-LINK server 将消息TLS加密后发给LB100
>
> 和case3不同，我们不需要再进行机器学习，而是可以根据我们建立账户时，预先植入的certificate进行解码，就能直接解析消息内容，而且消息长度仍是182byte，和之前测的一致。
>
> 给子图中的消息添加一条属性`"function"：“SP LB100 on"`
>
> 因此，只要能获得authorization code，就能建立虚假链接，预先植入certificate，从而为后续截取控制信息铺平道路。
>
> 采用基于备用信道的供给方法（参考文献20），从SQLite的文本中窃取TP-LINK的authorization code
>
> - 利用下面指令，备份指定应用程序（com.Target.app）的数据到指定文件（TargetApp.db）中，并且不备份应用程序本身的APK文件
>
>   ```sqlite
>   adb backup -f TargetApp.db -noapk com.Target.app
>   ```
>
> - 然后就可以直接访问数据库，获取其中以明文存储的authorization code

### Case5：smartphone  -- LB100

![](C:\Users\8208191402\Desktop\笔记\图片\攻击模式5.png)

> 攻击本地控制流，不涉及external server
>
> - 手机可以通过广播UDP消息的形式找到LB100
>
>   ```json
>   {"system":{"get_sysinfo":{} } }
>   ```
>
> - 灯泡回应自身state
>
> - 手机通过如下指令控制灯泡的开关
>
>   ```json
>   {"smartlife.iot.smartbulb.lightingservice":{
>       "transition_light_state":{
>           ...,"on_off":1,...
>       }
>   }}
>   ```
>
> - 广播UDP是加密的，但是大多数流量显示，这种加密模式是不变的，而且有着相同的负载内容，经过反向固件操作，获取它的源码，得到加密方式就是通过把消息和0XAB进行异或得到的。
>
> 于是有了攻击方案：
>
> - 在用户手机上安装恶意软件，软件在接入设备所在网络时进行UDP广播，找到攻击对象
> - 模拟真实加密方式，对指令进行UDP加密，直接控制LB100

### Case6：smartphone -- TP-LINK server -- LB100

![](C:\Users\8208191402\Desktop\笔记\图片\攻击模式6.png)

> 攻击在通过账号登录到TP-LINKserver的过程中，对LB100的绑定过程
>
> 这个过程中，手机找LB100的方式和case5是一样的：
>
> - 如果设备回应自己仍未被绑定：
>
>   ```json
>   {"smartlife.iot.common.cloud":
>    {"get_info"{
>     "username":"",
>     ...,
>     "binded":0,
>     "cld_connected":1,
>     ...
>    }}
>   }
>   ```
>
> - 手机就会发送绑定请求：
>
>   ```json
>   {"smartlife.iot.common.cloud":
>    {"bind":
>    {
>        "password":"***",
>        "username":"***@yahoo.com"
>    }}
>   }
>   ```
>
> - 之后灯泡把这个转发给TP-LINK server，很快server就会发送authorization code给手机
>
> 但是，设备在已绑定之后，仍会接受绑定的request，因此，可以按照case5，广播UDP，寻找指定的LB100对象，模拟正常用户进行绑定。