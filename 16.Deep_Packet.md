@[TOC](Deep packet:encrypted traffic classification)

# 1.Introduction

- 识别不同的应用类型以及他们的流量模式，可以更好的分配网络资源。

  - 目前网络架构从不对称链接（CS通信）向对称通信转变（P2P、voice over IP、video call），导致客户端产生了上传文件的通信需求，流量模式变得不再单一。因此，我们需要对用户使用的application类型进行识别，以提供对应的资源类型，满足用户端需求。
  - 此外，新的application类型的出现（网络通信中间件、加密通信），使得网络的复杂性和多样性增加，使得流量分类更加困难。

- 识别不同的网络流量类型，是实现高级网络管理的前提（提供合适的Quality-of-Service、异常检测、通信代价计算等等）

  - 数据加密和用户隐私保护使得流量具有区分度的特征变得难以获取。数据加密使用伪随机数，产生的流量不具备可区分的特征；用户隐私保护不允许我们通过深度包检测来获取更加复杂的特征。
  - 基于机器学习的方法易错，人工成本高，速度慢。

- 许多ISP ban掉了基于P2P的application，以减少带宽消耗和版权问题。因此，许多P2P应用使用嵌入协议和协议混淆的方式，来绕过流量监管系统，使得他的流量行为难以识别。

  > P2P使用的protocol embedding and obfuscation technology指的是在点对点（P2P）网络中使用的一种技术组合，用于嵌入通信协议并混淆通信以提高隐私和安全性。
  >
  > 1. Protocol Embedding（协议嵌入）：
  >    - Protocol Embedding 是指将通信协议的实现嵌入到P2P应用程序或系统中（将握手步骤隐藏或融入通信流量中，从而减少握手的可见性）。这确保了P2P节点之间遵循特定的通信规则和约定，从而实现互操作性。
  >    - 这对于确保P2P网络中的节点能够相互理解并进行有效通信非常重要，因为P2P网络中的各个节点可能运行在不同的操作系统和平台上，或使用不同的编程语言，需要一种共同的方式来协调和管理通信。
  > 2. Obfuscation Technology（混淆技术）：
  >    - Obfuscation Technology 是一种用于隐藏或混淆通信内容和元数据的技术，以提高通信的隐私和安全性。这是在P2P网络中重要的，因为P2P通信通常容易被监视。
  >    - 混淆技术包括加密通信内容、隐藏通信中的标识信息、改变通信流量的模式等，以防止第三方窥探或识别P2P通信。
  >    - 这有助于确保P2P网络中的通信内容对于不相关的观察者来说是难以理解或解释的，从而提高了用户的隐私和安全性。

目前的方法主要集中在对一个协议族进行分类，即流量描述（traffic characterization）（例如流媒体协议族、chat协议族、P2P协议族），没有精确到某一种特定应用（Spotify、BitTorrent）。因此，本文提出一种将特征提取和分类一体化系统。

- 能够实现网络流量描述和识别（traffic characterization and identification）
- 不需要人工提取特征
- 除了流量识别，还能应用识别
- 可以处理加密流量和复杂的通信模式

功能

- 根据流量特征，划分到主流的流量类别（FTP，P2P）
- 根据流量特征，识别终端用户的应用类别（BitTorrent，Skype）
- 可以识别加密流量

# 2.相关工作

目前主要的流量分类方法

- 基于端口的

  - 利用TCP/UDP header中的信息，结合某些应用或者网络协议的常用端口，识别流量类别。

  - 端口不会被加密影响。

  - 但是，端口混淆、NAT、端口转发、端口嵌入、随机端口分配等技术让这个方法不再适用。

    > 1. 端口混淆：端口混淆是一种网络安全技术，用于隐藏网络应用程序的真实端口号，从而增加攻击者破解应用程序的难度。它通过**将应用程序的流量伪装成其他类型的流量**，使得攻击者无法轻易地识别和攻击应用程序。常见的端口混淆技术包括基于HTTP协议的混淆、基于DNS协议的混淆等[1](https://www.secrss.com/articles/18469)。
    > 2. NAT：NAT（Network Address Translation，网络地址转换）是将IP数据报文头中的IP地址转换为另一个IP地址的过程。在实际应用中，NAT主要用于实现私有网络访问公共网络的功能。这种通过使用少量的公网IP地址代表较多的私网IP地址的方式，将有助于**减缓可用IP地址**空间的枯竭[2](https://www.h3c.com/cn/d_200812/624141_30003_0.htm)。
    > 3. 端口转发：端口转发是一种网络技术，用于**将网络流量从一个端口发送到另一个上，无论这两个端口是否属于同一台电脑**。在这里，端口不是某个物理实体，而是一个**监听网络活动的软件程序**。常见的端口转发使用场景包括使用路由器进行端口转发、使用SSH进行端口转发等[3](https://linux.cn/article-14415-1.html)。
    > 4. 端口嵌入：端口嵌入是一种嵌入式系统中的概念，用于与外部环境通信的通道。它可以是物理上的连接，也可以是软件定义的逻辑通道。端口可以用于输入和输出数据，以及控制信号的传输。在嵌入式系统中，我们通常使用端口与外部设备、传感器、执行器等进行交互[4](https://blog.csdn.net/ZrElixir/article/details/133147525)。
    > 5. 随机端口分配：随机端口分配是一种网络安全技术，用于增加攻击者破解应用程序的难度。它通过**在应用程序中随机分配端口号**，使得攻击者无法轻易地识别和攻击应用程序。常见的随机端口分配技术包括基于随机数生成器的分配、基于时间戳的分配等[5](https://www.jos.org.cn/jos/article/html/5620)。
    >    - Java中的Socket类默认会为每个套接字随机分配一个端口号。
    >    - 随机端口分配可能会对通信效率产生一定的影响，但这种影响通常是非常小的

- 基于深度包检测的

  - 使用预定义的pattern（正则表达式等）作为协议签名提取工具。每当有新的协议需要识别，就需要就爱如新的预定义pattern。
  - 用户隐私问题。

- 统计和机器学习方法的

  - 基于一个前提：统计特征一定能包含能够唯一标识一个应用的特征
  - 需要先验知识
  - 执行时间长（KNN）

# 3.神经网络相关

- 通过对外部输入的动态响应来处理信息，获取特征。（根据输入数据的变化和不同时间点的输入进行不同的输出）

- 深度学习框架=一种具有多个隐藏层的NNs

- 本文使用Autoencoder和CNN

  - Autoencoder，学习一种数据集的压缩表示方法

    - 自编码器是一种无监督学习的神经网络模型，其目的是学习输入数据的压缩表示方法。自编码器的训练过程包括两个阶段：编码和解码。在编码阶段，自编码器将输入数据压缩成一个低维向量，这个向量被称为编码。在解码阶段，自编码器将编码还原成原始数据。自编码器的目标是最小化重构误差，即输入数据和解码后的数据之间的差异。通过这种方式，自编码器可以学习输入数据的压缩表示方法，从而实现数据的降维和去噪等功能[1](https://blog.csdn.net/ProgramChangesWorld/article/details/51553683)[2](https://logic.pku.edu.cn/docs/20220116210822631003.pdf)[3](https://www.zhihu.com/question/518894983?utm_id=0)。

    - $$
      F_{W,b}(x)≈x\\
      W和b使整个网络的权重和偏差向量
      $$

    - 提供高等级的/复杂的、有区分度的特征

    - ![image-20231031122606509](https://s2.loli.net/2023/10/31/kYlyDetUQZRgKqf.png)

  - SAE，把多个AE堆到栈中，前一层输出连到后一层输入。训练过程的最优参数，使用贪心算法+层感知算法。

    - 首先，通过固定其它层的的参数，对每一层单独训练。
    - 然后，对整体模型执行微调，此时的反向传播涉及模型的所有权重。
    - ![image-20231031122619768](https://s2.loli.net/2023/10/31/X9hmQBWjLuObaT2.png)

  - CNN，每一层输出如下

    ![image-20231031122641961](https://s2.loli.net/2023/10/31/rxZvgKBXnQluiGE.png)

    - 对每一个输出层
      - 使用ReLU激活函数，使模型学习更复杂的特征。
      - 使用池化层，融合多个低维特征，维持特征局部不变性；同时减少输出特征图尺寸。
      - 一维CNN可以捕获网络数据包的相邻字节的空间依赖性，以寻找每个类（协议/应用类别）的可区分特征。

# 4.方法

![image-20231031123240415](C:\Users\8208191402\Desktop\笔记\图片\7BixIqZeTbGCFPL.png)

测试阶段，使用不同目的的训练网络执行对应任务。

### 数据集

- 数据集：“ISCX VPN-nonVPN，数据包根据产生的应用进行划分(e.g., Skype, and Hangouts, etc.)，也根据这个应用产生数据包的具体行为进行划分(e.g., voice call, chat, file transfer, or video call)。包含多种流量类别：

  - 正常流量

  - VPN，即私人使用的、包含多个分布式网站的网络覆盖层，通过隧道流量来在公共网络上通信。使用隧道传输传输IP数据包和确保安全远程服务/服务器连接是最重要的应用。VPN流量和普通流量一样，来自多个不同的应用，展示不同的通信行为。（voice call，chat等等）
  - Tor software，使用洋葱浏览器产生的流量，包含推特、谷歌、脸书/meta等label。Tor的目的是匿名通信，绕过网络监测。Tor建立的加密连接确保没有任何个人中继器能够获取数据包传输的完整路径。为了私密性和匿名性，Tor使用了复杂的端口混淆算法。

### 预处理

- 预处理

  - “ISCX VPN-nonVPN，是数据链路层数据，头部的以太网帧对本系统的应用识别和流量分类都无关，移除。
  - 对UDP数据包头部填充12字节，使其与TCP数据包头部长度相同。
  - 删除数据中的SYN，ACK，FIN标记的TCP数据包。
  - 删除DNS segments。
  - 包长统一：因为最大传输单元的存在，网络包的payload长度一般不超过1480字节，因此选择IP header和前1480个字节作为输入，使用0填充。
  - 对数据包的每一个字节，除以255，使输入的每一个值范围都在[0,1]范围内。
  - 为了防止网络通过数据包的IP地址对数据包进行分类，将IP地址字段 mask。
  - 至此，确保输入向量不会学习与分类任务无关的特征。
  - 数据集标签是根据产生应用或产生的用户行为标记的，因此进行重标记：
    - 应用识别：同一个应用产生的数据包保存到一个pcap文件
    - ![image-20231031161346805](https://s2.loli.net/2023/10/31/KNfYB8OSgMXqjWJ.png)
    - 流量描述：把不同应用的同一行为的、使用VPN/未使用VPN的流量化如同一个pcap文件。
    - ![image-20231031161641087](https://s2.loli.net/2023/10/31/RsjW2yB7mDagE5Y.png)
    - 下取样，删除多样本类的样本。

### 结构

- SAE，五个全连接层，分别有400,300,200,100,50个神经元，dropout=0.05，输出采用softamx分类器。
- CNN结构如下
- ![image-20231031161928053](https://s2.loli.net/2023/10/31/eKdShEWRnu4otc3.png)
- CNN用网格搜索（grid search）来进行超参数选择，使用两个连续卷积层和一个池化层，最后对输出展平成一维向量，经过三个全连接层，最终进行分类。

# 5.结果评估

- 使用Tensorflow作为后端，train-validate-test=64-16-20。
- 使用提前停止减少过拟合。
- 使用batch Normalization加速学习过程。

SAE：

- 每一层单独训练时，使用贪心的层感知（每次只训练单独的一层，以层为单位，所以层感知）算法，结合Adam优化。使用均方差。
- 整体的细粒度训练时，使用绝对交叉熵损失函数。

CNN：

- 和SAE的整体训练过程相似。

- 使用网格搜索来寻找最佳的超参数，分别对网络的卷积核大小、数量、步长进行测试。

- ![image-20231031163623293](https://s2.loli.net/2023/10/31/7HNagEDqrwzUFAh.png)

- 点颜色越深，表示可训练的参数越多，增加模型的容量，使其能够更好地拟合训练数据。

- 可见模型越复杂，效果不一定越好，且复杂模型会出现梯度消失/过拟合等问题。

- 结果如下

  - ![image-20231031164446580](https://s2.loli.net/2023/10/31/KnfvNPEkV7Y82sB.png)
  - ![image-20231031164458404](https://s2.loli.net/2023/10/31/hkP4diQ9vD7tLcX.png)

  

## 5.1与已有实验对比

  

Gil的实验通过人工添加时间相关的特征（流持续时间、每秒的流字节数）；Yamansavascilar的实验也是用了时间相关的特征，来进行应用识别。

![image-20231031165039967](https://s2.loli.net/2023/10/31/m2IZC4PUr1kLdv7.png)

之前的实验没有屏蔽IP地址，可能网络只是学习了这个特征，导致分类结果虚高。

## 5.2与传统方法对比

把本实验预处理输入添加必要标签后，传入传统方法中。

![image-20231031165731020](https://s2.loli.net/2023/10/31/KTFDUat6ixMPVjw.png)

# 6.讨论

在测试集上使用SAE，产生的行标准化的混淆矩阵。

> 行标准化混淆矩阵允许你查看模型预测在不同类别之间的分布，这样更容易理解。它有助于评估模型为每个类别单独执行的性能，包括精确度、召回率和F1分数等指标。
>
> 当你的数据集存在不平衡的情况，某些类别的样本数量明显少于其他类别时，行标准化混淆矩阵特别有用，因为它提供了一个更清晰的模型为每个类别的性能独立于类别频率的图像。
>
> 行标准化混淆矩阵通常在你希望评估多类分类模型的类别性能时使用。它提供了一个更好的理解模型在不同类别之间的区分能力，并可以用于基于模型预测做决策。

![image-20231031170302167](https://s2.loli.net/2023/10/31/jlfvPFGtbogiE9m.png)

> Hierarchical clustering（分层聚类）是一种聚类分析的方法，用于将数据集中的观测值或数据点分成具有层次结构的群组。这个方法的主要思想是将相似的数据点逐步合并到越来越大的群组中，最终形成一个树状结构，这棵树被称为"聚类树"或"树状图"。
>
> Hierarchical clustering有两种主要类型：凝聚式（agglomerative）和分离式（divisive）。
>
> 1. 凝聚式分层聚类：从一个初始状态开始，每个数据点都被认为是一个单独的聚类，然后逐步合并最相似的聚类，直到所有数据点都属于同一个聚类，或者达到某个停止条件。这个方法的输出是一个树状图，可以根据需要以不同的阈值来划分成不同数量的聚类。
> 2. 分离式分层聚类：与凝聚式相反，它是从一个包含所有数据点的大聚类开始，然后逐步将聚类分割成更小的子聚类，直到每个数据点都被单独分为一个聚类，或者达到停止条件。
>
> Hierarchical clustering的主要优点是它创建了一个层次结构，可以在不同的层次上检查和分析聚类，这有助于理解数据的分布和相似性。此外，它不需要提前指定要划分的聚类数量，因为它生成一个包含所有可能聚类数量的树状结构。

分层聚类可以更好的展示同一种应用的特征相似性关系。

分层聚类把应用分为七个组，结果如下：

![image-20231031170803919](https://s2.loli.net/2023/10/31/1RWDjBMfrK2yzbG.png)

可见，根据本系统聚类结果，

- 同一种class的应用在现实世界中也是相似的。
- 而且应用聚类和流量描述聚类的位置关系类似，因为相似应用的功能相似，使用的协议往往也是关联的。
- 流量描述聚类简单划分为VPN和No-VPN。

使用伪随机数的加密算法会产生不同的模式，因而被用于应用识别，即**本系统是通过不同加密行为本身的特征**，而不是加密内容来实现应用识别。

本系统无法识别仅包含Tor流量的网络，因为Tor加密行为发生在传输之前，deep packet是通过学习不同加密方案中，使用的不同随机数加密算法模式。Tor流量从Tor隧道进入网络，使用的是同一种加密算法，因此无法识别。